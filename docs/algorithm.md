*** 基数ソートの処理の流れ


-add_index_to_stack関数

まず、スタックの中の値に、数字が小さい順にindexを割り振る。

-get_max_bit関数

その次に、get_max_bitで、スタックの中の最も大きいindexのbitの桁数を計算する。


-radix_sort関数
:w::a
最下位ビット（i = 0）での処理:
初期状態: こっち側が先頭→[10, 01, 11, 00]  // インデックスの2進数表現

処理手順（最下位ビットを確認）:
1. 10 → 最下位ビット = 0 → pb でスタックB へ
   Stack A: [01, 11, 00]
   Stack B: [10]

2. 01 → 最下位ビット = 1 → ra でスタックA の末尾へ
   Stack A: [11, 00, 01]
   Stack B: [10]

3. 11 → 最下位ビット = 1 → ra でスタックA の末尾へ
   Stack A: [00, 01, 11]
   Stack B: [10]

4. 00 → 最下位ビット = 0 → pb でスタックB へ
   Stack A: [01, 11]
   Stack B: [00, 10]

スタックBの要素を全てスタックAへ戻す（pa操作）:
最終状態: [10, 00, 01, 11]



初期状態:
CopyA: [3, 1, 4, 2]    対応する2進数: 3(11), 1(01), 4(100), 2(10)
B: []
第1回目 (i=0: 最下位ビット)
Copy1. 3(11)チェック → 最下位ビットが1 → ra
A: [1, 4, 2, 3]
B: []

2. 1(01)チェック → 最下位ビットが1 → ra
A: [4, 2, 3, 1]
B: []

3. 4(100)チェック → 最下位ビットが0 → pb
A: [2, 3, 1]
B: [4]

4. 2(10)チェック → 最下位ビットが0 → pb
A: [3, 1]
B: [2, 4]

全てチェック後、Bの要素をAに戻す(pa)
A: [2, 4, 3, 1]  (最下位ビットが0の数が前に来る)
B: []
第2回目 (i=1: 2番目のビット)
Copy1. 2(10)チェック → 2番目のビットが1 → ra
A: [4, 3, 1, 2]
B: []

2. 4(100)チェック → 2番目のビットが0 → pb
A: [3, 1, 2]
B: [4]

3. 3(11)チェック → 2番目のビットが1 → ra
A: [1, 2, 3]
B: [4]

4. 1(01)チェック → 2番目のビットが0 → pb
A: [2, 3]
B: [1, 4]

全てチェック後、Bの要素をAに戻す(pa)
A: [1, 4, 2, 3]
B: []
第3回目 (i=2: 3番目のビット)
Copy1. 1(01)チェック → 3番目のビットが0 → pb
A: [4, 2, 3]
B: [1]

2. 4(100)チェック → 3番目のビットが1 → ra
A: [2, 3, 4]
B: [1]

3. 2(10)チェック → 3番目のビットが0 → pb
A: [3, 4]
B: [2, 1]

4. 3(11)チェック → 3番目のビットが0 → pb
A: [4]
B: [3, 2, 1]

全てチェック後、Bの要素をAに戻す(pa)
A: [1, 2, 3, 4]  (最終的にソートされた状態)
B: []
各ラウンドでの重要なポイント:

第1回目:

最下位ビットで分類
0のグループ(4, 2)と1のグループ(3, 1)に分かれる


第2回目:

2番目のビットで分類
0のグループ(1, 4)と1のグループ(2, 3)に分かれる
前回の順序を考慮しながら並び替え


第3回目:

最上位ビットで分類
0のグループ(1, 2, 3)と1のグループ(4)に分かれる
最終的な順序が確定
